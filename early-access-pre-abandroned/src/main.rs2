use id3::{Tag, TagLike};
use serde_json::{json, Value};
use std::fs::{self};
use std::io::prelude::*;
use std::path::Path;
use std::{fs::File, path::PathBuf};

fn main() {
    println!("Hello,Tiny Melody Server!");

    let folder_path = "/media/h2o2/扩展1/Music/LOCAL/pur";

    let (music_paths, cover_paths, folder_data) = scan_directory(&folder_path);

    if let Err(err) = fs::create_dir_all("web") {
        eprintln!("Failed to create web directory: {}", err);
        return;
    }

    save_paths(&music_paths,&cover_paths);
    save_folder_structure(&folder_data);
}

fn save_paths(music_paths: &[String], cover_paths: &Vec<String>) {
    let music_file = "web/music.list";
    let cover_file = "web/cover.list";

    if let Ok(mut file) = File::create(music_file) {
        for path in music_paths {
            if let Err(err) = writeln!(file, "{}", path) {
                eprintln!("Failed to write music path to file: {}", err);
            }
        }
    } else {
        eprintln!("Failed to create music path file");
    }
    if let Ok(mut file) = File::create(cover_file) {
        for path in cover_paths {
            if let Err(err) = writeln!(file, "{}", path) {
                eprintln!("Failed to write cover path to file: {}", err);
            }
        }
    } else {
        eprintln!("Failed to create cover path file");
    }
}

fn save_folder_structure(json_string: &str) {
    let folder_file = "web/folder.json";

    if let Ok(mut file) = File::create(folder_file) {
        if let Err(err) = write!(file, "{}", json_string) {
            eprintln!("Failed to write folder structure to file: {}", err);
        }
    } else {
        eprintln!("Failed to create folder structure file");
    }
}

fn scan_directory(path: &str) -> (Vec<String>, Vec<String>, String) {
    let mut music_paths: Vec<String> = Vec::new();
    let mut cover_paths: Vec<String> = Vec::new();
    let mut json_structure = json!({});

    // 递归遍历目录
    scan_recursive(
        path,
        &mut music_paths,
        &mut cover_paths,
        &mut json_structure,
    );

    let json_string = serde_json::to_string_pretty(&json_structure).unwrap();
    (music_paths, cover_paths, json_string)
}

fn scan_recursive(
    path: &str,
    music_paths: &mut Vec<String>,
    cover_paths: &mut Vec<String>,
    json_structure: &mut Value,
) {
    if let Ok(entries) = fs::read_dir(path) {
        let mut cover_check = true;
        for entry in entries {
            if let Ok(entry) = entry {
                let entry_path = entry.path();
                let entry_name = entry_path
                    .file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("");

                if entry_path.is_dir() {
                    let mut nested_json = json!({});
                    scan_recursive(
                        entry_path.to_str().unwrap(),
                        music_paths,
                        cover_paths,
                        &mut nested_json,
                    );
                    json_structure[entry_name] = nested_json;
                } else if entry_path.is_file() {
                    if let Some(extension) = entry_path.extension() {
                        if extension == "mp3" {
                            //Only Save Music Files Path
                            music_paths.push(entry_path.to_string_lossy().into());
                            //Resign the type
                            json_structure[entry_name] = json!({
                                "type": "mp3"
                            });
                        } else if extension == "jpg" && cover_check {
                            cover_check = false;
                            cover_paths.push(entry_path.to_string_lossy().into());
                            //Resign the cover
                            json_structure[entry_name] = json!({
                                "type": "jpg"
                            });
                        }
                    }
                }
            }
        }
    }
}

fn compress_and_copy_jpg(input_path: &str, output_dir: &str, index: u32) -> Result<(), Box<dyn std::error::Error>> {
    // 读取输入路径的图像文件
    let image = image::open(input_path)?;

    // 压缩图像为512x512像素
    let resized_image = image.resize_exact(512, 512, FilterType::Lanczos3);

    // 构建输出路径
    let output_filename = format!("{}{}.jpg", index, std::path::MAIN_SEPARATOR);
    let output_path = Path::new(output_dir).join("web/folder").join(output_filename);

    // 保存压缩后的图像到输出路径
    resized_image.save_with_format(&output_path, ImageFormat::Jpeg)?;

    Ok(())
}

#[derive(Debug)]
struct MusicInfo {
    artist: Option<String>,
    title: Option<String>,
    album: Option<String>,
    disc: Option<u32>,
    track: Option<u32>,
    year: Option<i32>,
}

fn music_parse(path: &PathBuf) -> Result<MusicInfo, Box<dyn std::error::Error>> {
    let tag = Tag::read_from_path(path)?;

    let music_info = MusicInfo {
        artist: tag.artist().map(|s| s.to_owned()),
        title: tag.title().map(|s| s.to_owned()),
        album: tag.album().map(|s| s.to_owned()),
        disc: tag.disc(),
        track: tag.track(),
        year: tag.year(),
    };
    Ok(music_info)
}
